package repository

import (
	"database/sql"
	"fmt"
	"time"

	"github.com/google/uuid"
	"github.com/securestor/securestor/internal/models"
)

type VulnerabilityRepository struct {
	db *sql.DB
}

func NewVulnerabilityRepository(db *sql.DB) *VulnerabilityRepository {
	return &VulnerabilityRepository{db: db}
}

func (r *VulnerabilityRepository) Create(vuln *models.Vulnerability) error {
	// Legacy function - new vulnerabilities table stores individual vulnerabilities, not counts
	// This is kept for backward compatibility but does nothing
	// TODO: Remove this when all callers are updated to use VulnerabilityDetail
	return nil
}

func (r *VulnerabilityRepository) GetByArtifactID(artifactID uuid.UUID) (*models.Vulnerability, error) {
	// Get vulnerability summary from the new schema
	query := `
        SELECT 
            COUNT(*) as total,
            SUM(CASE WHEN severity = 'critical' THEN 1 ELSE 0 END) as critical,
            SUM(CASE WHEN severity = 'high' THEN 1 ELSE 0 END) as high,
            SUM(CASE WHEN severity = 'medium' THEN 1 ELSE 0 END) as medium,
            SUM(CASE WHEN severity = 'low' THEN 1 ELSE 0 END) as low,
            MAX(created_at) as scanned_at
        FROM vulnerabilities
        WHERE artifact_id = $1
    `

	vuln := &models.Vulnerability{}
	var scannedAt sql.NullTime

	err := r.db.QueryRow(query, artifactID).Scan(
		&vuln.Total,
		&vuln.Critical,
		&vuln.High,
		&vuln.Medium,
		&vuln.Low,
		&scannedAt,
	)

	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, fmt.Errorf("failed to get vulnerability scan: %w", err)
	}

	vuln.ArtifactID = artifactID
	vuln.ID = artifactID // Use artifact ID as identifier for compatibility

	if scannedAt.Valid {
		vuln.ScannedAt = scannedAt.Time
		vuln.LastScan = scannedAt.Time.Format(time.RFC3339)
	} else {
		vuln.ScannedAt = time.Now()
		vuln.LastScan = time.Now().Format(time.RFC3339)
	}

	return vuln, nil
}

func (r *VulnerabilityRepository) GetHistory(artifactID int64) ([]models.Vulnerability, error) {
	// For backward compatibility, convert int64 to uuid.UUID (this shouldn't be used in new system)
	artifactUUID := uuid.New() // Placeholder - this function should not be used with new schema

	query := `
        SELECT 
            artifact_id,
            COUNT(*) as total,
            SUM(CASE WHEN severity = 'critical' THEN 1 ELSE 0 END) as critical,
            SUM(CASE WHEN severity = 'high' THEN 1 ELSE 0 END) as high,
            SUM(CASE WHEN severity = 'medium' THEN 1 ELSE 0 END) as medium,
            SUM(CASE WHEN severity = 'low' THEN 1 ELSE 0 END) as low,
            MAX(created_at) as created_at
        FROM vulnerabilities
        WHERE artifact_id = $1
        GROUP BY artifact_id
        ORDER BY created_at DESC
    `

	rows, err := r.db.Query(query, artifactUUID)
	if err != nil {
		return nil, fmt.Errorf("failed to get vulnerability history: %w", err)
	}
	defer rows.Close()

	var vulnerabilities []models.Vulnerability
	for rows.Next() {
		var vuln models.Vulnerability
		var createdAt sql.NullTime

		err := rows.Scan(
			&vuln.ArtifactID,
			&vuln.Total,
			&vuln.Critical,
			&vuln.High,
			&vuln.Medium,
			&vuln.Low,
			&createdAt,
		)

		if err != nil {
			return nil, fmt.Errorf("failed to scan vulnerability: %w", err)
		}

		if createdAt.Valid {
			vuln.ScannedAt = createdAt.Time
			vuln.LastScan = createdAt.Time.Format(time.RFC3339)
		}

		vulnerabilities = append(vulnerabilities, vuln)
	}

	return vulnerabilities, nil
}
